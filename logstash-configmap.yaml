apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-pipeline
data:
  logstash.conf: |
    input {
      beats {
        port => 5044
      }
    }

    filter {
      # Elastic 8.18+ Synthetic Monitors (Heartbeat integration inside Elastic Agent)
      # Force correct data_stream fields so Logstash routes to the official synthetics-* data streams

      if [event][module] == "heartbeat" or "heartbeat" in [tags] or [monitor] {
        mutate {
          # Core data_stream fields required for synthetics data streams
          replace_field => { "[data_stream][type]" => "synthetics" }

          # Route based on monitor type
          if [monitor][type] == "tcp" {
            replace_field => { "[data_stream][dataset]" => "tcp" }
          }
          else if [monitor][type] == "http" {
            replace_field => { "[data_stream][dataset]" => "http" }
          }
          else if [monitor][type] == "browser" {
            replace_field => { "[data_stream][dataset]" => "browser" }
          }
          else if [monitor][type] == "icmp" {
            replace_field => { "[data_stream][dataset]" => "icmp" }
          }
          else {
            # Fallback for any new/future types
            replace_field => { "[data_stream][dataset]" => "%{[monitor][type]}" }
          }

          # Change this only if you use non-default namespace in Fleet/Agent policy
          replace_field => { "[data_stream][namespace]" => "default" }

          # Optional: clean up or add tags
          add_tag => [ "via_logstash", "synthetic_monitoring" ]
        }
      }
    }

    output {
      elasticsearch {
        hosts => [ "https://elasticsearch.yourdomain.com:9200" ]   # your actual endpoint(s)

        user => "elastic"
        password => "${ES_PASSWORD}"

        # This enables data stream mode and auto-routing
        data_stream => true
        data_stream_auto_routing => true

        ssl => true
        ssl_verification_mode => "certificate"   # or "full"
        cacert => "/etc/logstash/certs/ca.crt"
      }

      # Remove in production
      stdout { codec => rubydebug }
    }
